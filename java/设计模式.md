## 设计原则

> https://www.cnblogs.com/whgk/p/12448925.html



### 一、架构设计七大原则

**开闭原则**：对扩展开放，对修改关闭。

**单一职责原则**：一个类、接口、方法只做一件事。

**接口隔离原则**：尽量保证接口的纯洁性，客户端不应该依赖不需要的接口。

**迪米特法则**：又叫最少知道原则，一个类对其所依赖的类知道得越少越好。

**里氏替换原则**：子类可以扩展父类的功能但不能改变父类原有的功能。

**依赖倒置原则**：通过抽象使各个类或者模块不相互影响，实现松耦合。

**合成复用原则**：尽量使用对象组合、聚合，而不使用继承关系达到代码复用的目的。



#### Open-Closed Principle	开闭原则

> 开闭原则（Open-Closed Principle）是指软件中的对象（类、模块、函数等）应该对于扩展是开放的，但是对于修改是封闭的。

* 梅耶开闭原则

>  [伯特兰·迈耶](https://baike.baidu.com/item/伯特兰·迈耶)一般被认为是最早提出开闭原则这一术语的人，在他1988年发行的《面向对象软件构造》中给出。这一想法认为一旦完成，一个类的实现只应该因错误而修改，新的或者改变的特性应该通过新建不同的类实现。新建的类可以通过继承的方式来重用原类的代码。衍生的子类可以或不可以拥有和原类相同的接口。

梅耶的定义提倡实现继承。具体实现可以通过继承方式来重用，但是接口规格不必如此。已存在的实现对于修改是封闭的，但是新的实现不必实现原有的接口。



* 多态开闭原则：

> 在20世纪90年代，开闭原则被广泛的重新定义由于[抽象化](https://baike.baidu.com/item/抽象化)接口的使用，在这中间实现可以被改变，多种实现可以被创建，并且多态化的替换不同的实现。

相比梅耶的使用方式，多态开闭原则的定义倡导对[抽象基类](https://baike.baidu.com/item/抽象基类)的继承。接口规约可以通过继承来重用，但是实现不必重用。已存在的接口对于修改是封闭的，并且新的实现必须，至少，实现那个接口。

罗伯特·C·马丁1996年发表的文章《开闭原则》是使用这种方法的启发式著作。在2001年，Craig Larman把开闭原则关联到了Alistair Cockburn的名为受护的变量的模式以及David Parnas关于[信息隐藏](https://baike.baidu.com/item/信息隐藏)的讨论。

总结：对扩展开放，对修改关闭



#### Dependence Inversion Principle	依赖倒置原则

> 依赖倒置原则（Dependence Inversion Principle,DIP）是指设计代码结构时,高层模块不应该依赖底层模块，二者都应该依赖其抽象。抽象不应该依赖细节，细节应该依赖抽象。通过依赖倒置，可以减少类与类之间的耦合性，提高系统的稳定性，提高代码的可读性和可维护性，并且能够降低修改程序所造成的风险。这是一个比较重要的设计原则，在我们日常开发中，经常有使用该思想的场景，能避免很多时候业务更改时，只需要改动少量代码就可以完成需求。下面我们通过一个例子，来深入理解该思想。



如：原本需要调用2个方法，抽象一个接口，改为倒置，从依赖这两个方法的细节变成通过调用者自己实例化控制

依赖倒置原则的核心思想。通过抽象课程学习的接口，减少了类与类之间的耦合性和可维护性。当又有新的课程添加，我们直接可以再添加一个实现类，通过传参的方式告知Tom，而不在需要修改底层代码（也体现了开闭原则）。

大家要切记：以抽象为基准比以细节为基准搭建起来的架构要稳定的多，因此在拿到需求之后，要面向接口编程，先顶层再细节设计代码结构。



#### Simple Responsibility Principle	单一职责原则

> 单一职责（Simple Responsibility Pinciple,SRP）是指不要存在多于一个导致类变更的原因。假设我们有一个类负责两个职责，一旦发生需求变更，修改其中一个职责的代码，有可能导致另外一个职责的功能发生故障。这样一来，这个类就存在两个导致类发生变更的原因。如何解决这个问题呢？将两个职责用两个类来实现，进行解耦。后期需求变更维护互不影响。这样的设计，可以降低类的复杂度，提高类的可读性，提高系统的可维护性，降低变更引起的风险。

总体来说，就是一个类、接口或方法只负责一项职责，多的职责尽量解耦



#### Interface Segregation Principle	接口隔离原则

> 接口隔离原则（Interface Segregation Principke,ISP）是指用多个专门的接口，而不使用单一的总接口，客户端不应该依赖它不需要的接口。这个原则知道我们在设计接口时应当注意以下几点：

（1）一个类对另一个类的依赖应该建立在最小接口之上。

（2）建立单一接口，不要建立庞大臃肿的接口。

（3）尽量细化接口，接口中的方法尽量少（不是越少越好，一定要适度）。

接口隔离原则符合我们常说的高内聚、低耦合的设计思想，可以使类有很好的可读性、可扩展性和可维护性。我们在设计接口的时候，要多花时间去思考，要考虑业务模型，包括对以后可能发生变化的地方做一些预判。所以，对于抽象、对于业务模型的理解是非常重要的。



#### Law of Demeter 迪米特原则

> 迪米特原则（Law of Demeter LoD）是指一个对象应该对其他对象保持最少的了解，又叫最少知道原则(Least Knowledge Principle，LKP)，尽量降低类与类之间的耦合度。迪米特原则主要强调：只和朋友交流，不和陌生人说话。出现在成员变量、方法的输入、输出参数中的类可以称为成员朋友类，而出现在方法体内部的类不属于朋友类。

总结：简述就是一个方法调用另一个方法时，逻辑需要清晰，不需要吧与当前类无关的逻辑杂乱的堆在一起



#### Liskov Substitution Principle	里氏替换原则

> 里氏替换原则（Liskov Substitution Priciple，LSP）是指如果对每一个类型为T1的对象O1，都有类型为T2的对象O2，使得以T1定义的所有程序P在所有对象O1都替换成O2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。

​	这个定义看上去还是比较抽象的，我们要重新理解一下。可以理解为一个软件实体如果适用于一个父类，那么一定适用其子类，所以引用父类的地方必须能透明的使用其子类的对象，子类对象能够替换父类对象，而程序逻辑不变，根据这个理解，引申含义为：子类可以扩展父类的功能，但不能改变父类原有的功能。

（1）子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。

（2）子类可以增加自己特有的方法。

（3）当子类的方法重载父类的方法时，方法的前置条件（即方法的输入、入参）要比父类的方法输入参数更宽松。

（4）当子类的方法实现父类的方法时（重写、重载或实现抽象方法），方法的后置条件（即方法的输出、返回值）要比父类更严格或与父类一样。

使用里氏替换原则有以下优点：

（1）约束继承泛滥，是开闭原则的一种体现。

（2）加强程序的健壮性，同事变更时也可以做到非常好的兼容性，提高程序的可维护性和扩展性，降低需求变成时引入的风险。

现在来描述一个经典的业务场景，用正方形、矩形和四边形的关系说明里氏替换原则，我们都知道正方形一个特殊的矩形，所以就可以创建一个父类Rectangle：



#### Composite/Aggregate Reuse Principle	合成复用原则

> ​	合成复用原则（Composite/Aggregate Reuse Principle,CARP）是指尽量使用对象组 合(has-a)/聚合(contanis-a)，而不是继承关系达到软件复用的目的。可以使系统更加灵 活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少。

继承我们叫做 白箱复用，相当于把所有的实现细节暴露给子类。

组合/聚合也称之为 黑箱复用，对类以外的对象是无法获取到实现细节的。

要根据具体的业务场景来做代码设计， 其实也都需要遵循 OOP 模型。







## 设计模式

https://www.cnblogs.com/whgk/p/12508859.html

### 单例模式

> java中单例模式是一种常见的设计模式，单例模式主要三种写法：懒汉式单例、饿汉式单例、登记式单例。

单例模式的特点：

1. 单例模式只能有一个实例

2. 单例类必须自己创建自己的唯一实例

3. 单例类必须给所有其他对象提供这一实例



单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。在计算机系统中，==线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例==。这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个Printer Spooler，以避免两个打印作业同时输出到打印机中。每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。总之，选择单例模式就是为了避免不一致状态，避免政出多头。



##### 注意：

* 反射破坏单例

* 反序列化破坏单例



##### 常见单例的实现：

* 懒汉

```java
synchronized (Singleton.class) {
	if(XXX == null){
		实例化
	}
}
```

* 静态内部类

```java
public class Singleton {  

  private static class LazyHolder {  
     private static final Singleton INSTANCE = new Singleton();  
  }  
  
  private Singleton (){}  

  public static final Singleton getInstance() {  
     return LazyHolder.INSTANCE;  
  }  
}
```

* 饿汉式：

Spring中IOC容器ApplicationContext本身就是典型的饿汉式单例

```java
//饿汉式单例类.在类初始化时，已经自行实例化 
public class Singleton1 {
  private Singleton1() {}
  private static final Singleton1 single = new Singleton1();

  //静态工厂方法 
  public static Singleton1 getInstance() {
    	return single;
	}
}
```



### 观察者模式：ContextLoaderListener 又名订阅模式

观察者模式的本质就是，被观察者对象持有观察者对象的引用，由被观察者去通知了观察者去做了某件事。



### 工厂模式：BeanFactory



### 装饰器模式：BeanWrapper	

原有类的附加功能抽离出来，简化原有类的逻辑（一种特殊的代理模式）



### 代理模式：AopProxy。  

静态代理：方法当参数传递后执行相关方法，委托。动态代理：差不多，通过反射的机制，代理一类对象

### 委派模式：DispatcherServlet

### 策略模式：HandlerMapping

### 适配器模式：HandlerAdapter 

改造方法 具体为调用适配器方法时适配器内部方法再调用目标不可直接有的方法，嵌套一层逻辑。

### 模板模式：JdbcTemplate 







