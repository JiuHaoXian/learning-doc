# Java数据结构及其原理



## 数组

```
int[] data = new int[100]；data[0]  = 1;
```

##### 优点：

1、按照索引查询元素速度快
2、按照索引遍历数组方便

##### 缺点：

1、数组的大小固定后就无法扩容了
2、数组只能存储一种类型的数据
3、添加，删除的操作慢，因为要移动其他的元素。

##### 适用场景：

频繁查询，对存储空间要求不大，很少增加和删除的情况。



## 栈

栈是一种特殊的线性表，仅能在线性表的一端操作，栈顶允许操作，栈底不允许操作。 栈的特点是：先进后出，或者说是后进先出，从栈顶放入元素的操作叫入栈，取出元素叫出栈。

栈的结构就像一个集装箱，越先放进去的东西越晚才能拿出来，所以，栈常应用于实现递归功能方面的场景，例如**斐波那契数列**。



## 队列

队列与栈一样，也是一种线性表，不同的是，队列可以在一端添加元素，在另一端取出元素，也就是：先进先出。从一端放入元素的操作称为入队，取出元素为出队

使用场景：因为队列先进先出的特点，在多线程阻塞队列管理中非常适用。



## 链表

链表是物理存储单元上**非连续的、非顺序**的存储结构，**数据元素的逻辑顺序是通过链表的指针地址实现**，每个元素包含两个结点，一个是存储元素的数据域 (内存空间)，另一个是指向下一个结点地址的指针域。根据指针的指向，链表能形成不同的结构

例如单链表，双向链表，循环链表等。

##### 结构：

[数据域｜下一个结点的指针域]		[数据域｜下一个结点的指针域]		[数据域｜下一个结点的指针域]

##### 优点：

不需要初始化容量，可以任意加减元素；
添加或者删除元素时只需要改变前后两个元素结点的指针域指向地址即可，所以添加，删除很快；

##### 缺点：

因为含有大量的指针域，**占用空间较大**；
**查找**元素需要遍历链表来查找，**非常耗时**。

适用场景：
数据量较小，需要频繁增加，删除操作的场景



## 树

**树**是一种数据结构，它是由n（n>=1）个有限节点组成一个具有层次关系的集合

##### 特点：

* 每个结点有零个或多个子结点

* 没有父结点的称为父结点

* 每个非父结点有且只有1个父结点

- 除了根节点外，每个子节点可以分为多个不相交的子树



### 二叉树

##### 特点：

* 每个结点最多只有两个子结点
* 左子树与右子树是有顺序的且不能颠倒
* 即使某结点只有一个子树，也要区分左右子树

完全二叉树：编号与索引一致



### 平衡二叉树

平衡二叉树的性质如下：

1. 树的左右高度差不能超过1。
2. 任何往下递归的左子树与右子树，必须符合第一条性质。
3. 没有任何节点的空树或只有根节点的树也是平衡二叉树。



### 二叉查找树（二叉排序树）

对于任意节点来说，它的左子树上所有节点的值都小于它，而它的右子树上所有节点的值都大于它。二叉查找树非常适合数据查找。



### AVL 树（平衡二叉查找树）

增加和删除节点后通过树形旋转重新达到平衡。右旋是以某个节点为中心，将它沉入当前右子节点的位置，而让当前的左子节点作为新树的根节点，也称为顺时针旋转；同理，左旋是以某个节点为中心，将它沉入当前左子节点的位置，而让当前右子节点作为新树的根节点，也称为逆时针旋转。查找、插入和删除在平均和最坏情况下的时间复杂度都是LogN。增加和删除元素的操作则可能需要借由一次或多次旋转，以实现树的重新平衡。



### 红黑树（特殊的AYL树 自平衡二叉树 ）

[30张图带你彻底理解红黑树 - 简书 (jianshu.com)](https://www.jianshu.com/p/e136ec79235c)

**时间复杂度：O(log n)**

==**有红必有黑，红红不相连**==

##### 性质：

* 它的任一子树必须为红黑树

* 结点是红色或黑色
* 根结点是黑色
* 所有叶子都是黑色。（叶子是NIL结点，java中为NULL）
* 每个红色结点的两个子结点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色结点）
* 从任一节结点其每个叶子的所有路径都包含相同数目的黑色结点（重要）
* 衍生：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长



##### 插入算法：

```
RB-INSERT (T,z) {

1 按二叉查找树的插入步骤将结点 z 插入到 T 中；

2 color[z]=RED；//为满足黑色数量相同

3 while(z 不是根结点 &&color[z->parent]= =RED) {Insert-Fixup(T,z);}

4 color[root[T]]=BLACK； } [2]
```

###### 分析：因为如果插入的是黑色结点，那么不满足每一个路径黑色结点数量相同，所以插入的结点一定要设为红色，但是如果Z的父结点也是红色，违反了每个红色结点的两个子结点都是黑色的性质。



##### 查找算法：

```
 final Entry<K,V> getEntry(Object key) {
        // Offload comparator-based version for sake of performance
        if (comparator != null)
            return getEntryUsingComparator(key);
        if (key == null)
            throw new NullPointerException();
        @SuppressWarnings("unchecked")
            Comparable<? super K> k = (Comparable<? super K>) key;
        Entry<K,V> p = root;
        while (p != null) {
            int cmp = k.compareTo(p.key);
            if (cmp < 0)
                p = p.left; // 当前元素大于目标元素，向左找
            else if (cmp > 0)
                p = p.right; // 当前元素小于目标元素，向右找
            else
                return p;
        }
        return null;

}
```



##### 删除算法：

```
RB-DELETE(T,z) {
1 if (z 的左右子结点均为 NIL)
2 { NIL 结点代替 z 的位置； delete(z); }
3 else if (z 有一个子结点为 NIL)
4 {z 的非 NIL 子结点代替 z 的位置；delete(z); }
5 else
6 {将红黑树中序遍历中 z 的后继结点 s 的值赋给 z; delete(s); }
7 if (删除的结点是黑色的) Delete-Fixup(T,x); /*x 指向代替删除结点的结点 */ } [2]
```

###### 分析：若删除的结点是红色，则不做任何操作，红黑树的任何属性都不会被破坏；若删除的结点是黑色的，这时执行一个 Delete-Fixup（）来修补这棵树。 一个结点被删除之后，一定 有一个它的结点代替了它的位置，即使是叶结点被删除后，也会有一个空结点来代替它的位置。 设指针 x 指向这个代替位置的结点，同时引入指向 x 兄弟的指针 w，这里均假设 x 是 x->parent 的左子结点，则 w 是 x->parent 的右子结点，如果实际遇到相反的情 况，只要把所有操作中的左、右 互反一下就可以了。

在红黑树上只读操作不需要对用于二叉查找树的操作做出修改，因为它也是二叉查找树。但是，在插入和删除之后，红黑属性可能变得违规。恢复红黑属性需要少量(O(log n))的颜色变更（这在实践中是非常快速的）并且不超过三次[树旋转](https://baike.baidu.com/item/树旋转)（对于插入是两次）。这允许插入和删除保持为 O（log n)）次，但是它导致了非常复杂的操作。

##### 左旋/右旋：

将旋转点作为支点，拎起来作为父节点，将中心子节点移到操作前点父节点下。



**面对频繁的插入和删除，红黑树更为合适**；**面对低频修改、大量查询时，AVL树将更为合适**。

