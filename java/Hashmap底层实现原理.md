# Hashmap底层实现原理



## Hash计算原理

> 主要分为两步

#### 第一步：

> 调用hashCode()方法，计算hashCode，然后与自己>>>16（无符号右移运算）的值进行XOR（二进制按位异或运算）。

```java
int h;
hash = (key == null) ? 0 : (h = key.hashCode()) ^ (h>>>16);

//二进制异或（XOR）可以理解为不进位的加法运算，效率会更高
//>>> 运算符：在表达式中执行无符号右移

//例：
//h= 							0010001100010111 0100011101001101
//h >>> 16 =					0000000000000000 0010001100010111
//
//h								0010001100010111 0100011101001101
//h >>> 16						0000000000000000 0010001100010111
//h ^ (h >>> 16) =				0010001100010111 0110010001011010
//此时通过右移和异或低16位包含高16位和原本低16位的信息
```

#### 第二步：

> 进行数据压缩，数组长度减一与第一步的值做”与“运算，index = (n - 1) & hash 

```java
index = (n - 1) & hash 
    
//&运算符：同一则一
    
//例子：设n=16
//hash = h ^ (h >>> 16) =		0010001100010111 0110010001011010
//(n - 1) =						0000000000000000 0000000000001111
//index =						0000000000000000 0000000000001010
```



##### 为什么要右移16？

其实是为了**减少碰撞，进一步降低hash冲突的几率**。int类型的数值是4个字节（byte），每个字节8bit，所有有32位，右移16位异或可以同时保留高16位与低16位的特征



##### 为什么要进行异或运算？

因为此时通过右移和异或运算后，低16位包含高16位和原本低16位的信息，原数据信息的高地位特征都得到保留，提高数据复杂度。

如果不进行16右移运算，第二部（n-1）的二进制为000…….1111（假如数组长度为16），那么与第一步计算值计算“与”后，Hash将丢失全部高位信息，那么hash碰撞出现的几率将是非常恐怖的，



##### 为什么index = (n - 1) & hash ？

为了压缩数据，为什么减一，为什么默认16，因为16-1刚好二进制位1111，做“与”运算时防止出现全是000000的情况



#### 总结：

上面提到的所有问题，最终目的还是为了让哈希后的结果更均匀的分布，减少哈希碰撞，提升hashmap的运行效率