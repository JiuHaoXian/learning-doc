#### hashmap的get方法是什么?

答：ashMap的get方法的实现，其判断标准是通过hashCode和equals方法。



#### 如果多线程中一定要使用hashmap，怎么做？

并发操作HashMap，是有可能带来死循环以及数据丢失的问题的

1. 加锁，使用Synchronized关键字、Lock，但是这样实现方式性能远低于分段锁的ConcurrentHashMap
2. 使用Collections.synchronizedMap(Map map)方法，可以将HashMap变成一个同步的容器（拥有锁限制的同步机制）



#### 线程的状态，如何避免死锁，如何让线程同步？

1. 加锁顺序（线程按照一定的顺序加锁）
2. 加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）
3. 死锁检测



#### 什么是线程池？

一个线程池管理了一组**工作线程**，同时它还包括了一个用于放置等待执行 任务的**任务队列（阻塞队列）**。



#### 线程池的原理是什么?

默认情况下，在创建了线程池后，线程池中的线程数为 0。当任务提交给线程池之后的处理策略如下：

1. 如果此时线程池中的数量小于 corePoolSize（核心池的大小），即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务（也就是每来一个任务，就要创建一个线程来执行任务）。

2. 如果此时线程池中的数量大于等于 corePoolSize，但是缓冲队列 workQueue 未满，那么任务被放入缓冲队列，则该任务会等待空闲线程将其 取出去执行。

3. 如果此时线程池中的数量大于等于 corePoolSize ， 缓 冲 队 列 workQueue 满，并且线程池中的数量小于 maximumPoolSize（线程池 最大线程数），建新的线程来处理被添加的任务。

4. 如果 此时线程池中的数量 大 于 等 于 corePoolSize， 缓 冲 队列 workQueue 满，并且线程池中的数量等于 maximumPoolSize，那么通 过 RejectedExecutionHandler 所指定的策略(任务拒绝策略)来处理此任务。

也就是处理任务的优先级为：核心线程 corePoolSize、任务队列 workQueue、最大线程 maximumPoolSize，如果三者都满了，使用 handler 处理被拒绝的任务。

5. 特别注意，在 corePoolSize 和 maximumPoolSize 之间的线程 数会被自动释放。当线程池中线程数量大于 corePoolSize 时，如果某线程 空闲时间超过 keepAliveTime，线程将被终止，直至线程池中的线程数目不 大于 corePoolSize。这样，线程池可以动态的调整池中的线程数。



#### 使用线程池的好处？

1.通过重复利用已创建的线程，减少在创建和销毁线程上所花的时间以及系 统资源的开销。

2.提高响应速度。当任务到达时，任务可以不需要等到线程创建就可以立即 执行。

3.提高线程的可管理性。使用线程池可以对线程进行统一的分配和监控。

4.如果不使用线程池，有可能造成系统创建大量线程而导致消耗完系统内 存。