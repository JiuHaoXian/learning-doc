##### 什么是final？

* final类：不能继承，不能重写。

* final方法：可以继承，不能重写。

* final成员变量：表示常量，不可修改。






##### JAVA集合交集的几种计算方法？

1. JDK自带方法

   最常用的求交集方法，在小数据量的时候没什么问题，一旦两个集合的数据量达到几十万级别时，效率就严重偏低，底层实际上也是**两个for循环加一个contains判断**，只不过JDK做了一些相应优化，不是单纯O(n^2)的双重for循环

2. ==Guava==集合工具类

   Guava是谷歌出的一个工具类，里面包含了很多实用的方法，求交集的方法为Sets.intersection(list, list2)实际测试下来相当高效。

3. Java8并行流（Stream）

   parallelStream()借用了Java7的Fork/Join框架，采用分治+多线程的思想来求交集

4. 双指针法

   **双指针法又称拉链法**，就是先将两个集合排序，然后借用了**二路归并排序**的思想，利用两个指针分别在两个集合里面做标记，比较大小然后滑动，最后得到结果。

5. BitMap方法

   将数据存进两个bitMap中，然后进行与操作，得到最终结果，属于一种空间换时间的方法，BitMap思想在海量数据处理中有很多妙用。



##### 除了Synchronized、Lock如何实现线程安全？

1. 其实现原理都是利用借助了类加载的时候初始化单例。即借助了ClassLoader的线程安全机制。如：枚举，单例，

2. 使用CAS。

   CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。

   实现单例的方式如下：用CAS的好处在于不需要使用传统的锁机制来保证线程安全,CAS是一种基于忙等待的算法,依赖底层硬件的实现,相对于锁它没有线程切换和阻塞的额外消耗,可以支持较大的并行度。

   CAS的一个重要缺点在于如果忙等待一直执行不成功(一直在死循环中),会对CPU造成较大的执行开销。

   另外，如果N个线程同时执行到singleton = new Singleton();的时候，会有大量对象创建，很可能导致内存溢出。